from __future__ import annotations

import re
from typing import Iterable

PAGE_FOOTER_PATTERNS = (
    re.compile(r"^\s*page\s*\d+\s*$", re.IGNORECASE),
    re.compile(r"^\s*第?\s*\d+\s*页\s*$"),
)

NOISE_TOKENS = {"扫描件", "Generated by", "版权所有"}

ZERO_WIDTH_PATTERN = re.compile(r"[\u200B\u200C\u200D\uFEFF]")
MULTISPACE_PATTERN = re.compile(r"\s{2,}")


def _is_noise_line(line: str) -> bool:
    stripped = line.strip()
    if not stripped:
        return False
    if any(pattern.match(stripped) for pattern in PAGE_FOOTER_PATTERNS):
        return True
    return any(token in stripped for token in NOISE_TOKENS)


def _normalize_line(line: str) -> str:
    line = ZERO_WIDTH_PATTERN.sub("", line)
    line = line.strip("\t ")
    line = MULTISPACE_PATTERN.sub(" ", line)
    return line


def _dedupe_blank_lines(lines: Iterable[str]) -> list[str]:
    cleaned: list[str] = []
    previous_blank = False
    for line in lines:
        if line:
            cleaned.append(line)
            previous_blank = False
            continue
        if not previous_blank:
            cleaned.append("")
            previous_blank = True
    return cleaned


def clean_ocr_text(text: str) -> str:
    """Normalize OCR output to improve downstream AI prompts."""

    if not text:
        return ""

    text = text.replace("\r\n", "\n")
    raw_lines = text.split("\n")
    normalized_lines = [
        _normalize_line(line)
        for line in raw_lines
        if not _is_noise_line(line)
    ]

    collapsed = _dedupe_blank_lines(normalized_lines)
    # Remove leading / trailing blank lines that may remain after dedupe
    while collapsed and not collapsed[0]:
        collapsed.pop(0)
    while collapsed and not collapsed[-1]:
        collapsed.pop()

    return "\n".join(collapsed)
